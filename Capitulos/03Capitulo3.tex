%---------------------------------------------------------------------
%
%                          Capítulo 3
%
%---------------------------------------------------------------------

\chapter{Sustracción de Imágenes}
\label{cap3}

\begin{FraseCelebre}
\begin{Frase}
%  weon \\
%  que chotas
\end{Frase}
\begin{Fuente}
\end{Fuente}
\end{FraseCelebre}

%\begin{resumen}
%...
%\end{resumen}

%-------------------------------------------------------------------
\section{Introducción}
%-------------------------------------------------------------------

En décadas recientes, la observación de eventos transitorios ha tenido un auge 
gracias a \textit{wide-field time-domain surveys} como PS1 \citep{Chambers_2016}, 
ZTF  \citep{Bellm_2019}, y ATLAS \citep{Tonry_2018}. Todos ellos utilizan 
la sustracción de imágenes (DIA) como método de identificación y extracción 
de curvas de luz de los objetos observados. 

La sustracción de una imagen respecto a otra permite identificar diferencias entre ellas, 
lo cual resulta especialmente útil en diversas disciplinas como la meteorología, 
la medicina, el análisis de patrones o el estudio del crecimiento urbano. 
En astronomía, técnicas como el ajuste de la función PSF 
y la sustracción de imágenes son esenciales para detectar fenómenos astronómicos 
cuya intensidad varía con el tiempo, como ocurre en eventos transitorios y estrellas variables.

Las primeras propuestas del método de sustracción de imágenes fueron hechas 
por \citet{Phillips_1995} y \citet{Tomaney_1996}, proponiendo el 
uso de un kernel de convolución para hacer coincidir la función de dispersión puntual (PSF) entre 
dos imágenes. No obstante, su método describe la necesidad de determinar 
la PSF para cada estrella brillante aislada, lo cual resultaba lento, 
ineficiente y poco robusto \citep{Angulo_2025}. 

Sin embargo, no fue hasta las implementaciones de \citet{Kochanski_1996}, 
\citet{Alard_1998}, y \citet{Alard_2000} que el método se volvió más 
robusto, eficiente y de rápida implementación. 

Este método de detección de variabilidad resulta particularmente valioso en el estudio 
de cúmulos abiertos y globulares. Su implementación facilita la identificación de 
estrellas variables incluso en regiones densamente pobladas, donde otras técnicas 
fotométricas suelen tener dificultades, 
especialmente cerca del centro del cúmulo. \citep{TRIFFID_observations2013}.

Existe una gran variedad de paquetes de 
software que siguen utilizando los mismos principios de la sustracción 
de imágenes con sus respectivas variaciones, como lo son
%PSFMatch \citep{phil_dav_PSFMatch_95}; 
Hotpants \citep{Becker_hotpants_2015}, 
SFFT \citep{Hu_2022},
DANDIA \citep{Bramich_2008},
ZOGY \citep{Zackay_2016},  
CrossConv \citep{YuanAkerlof_CrossConv_2008}.

En nuestro caso, implementaremos la sustracción de imágenes directamente mediante el uso del 
paquete ISIS \citep{Alard_1998} sobre nuestras observaciones realizadas 
en el Observatorio Astronómico Nacional de la Sierra de San Pedro Mártir. 

Si bien tratar directamente con el programa viene con sus complicaciones, 
queremos realizar una valoración sobre otras implementaciones hechas en un 
más alto nivel de código e incluso de software privado. 

En todos los métodos se toma una imagen de referencia R y una de ciencia I, 
la cual puede ser aproximadamente modelada como: 

$$ I \approx R \ast K + B_{kg} $$

para un fondo $B_{kg}$ y un kernel $K$.

De forma que la imagen óptima de sustracción queda como:

$$ D = I - (R \ast K + B_{kg}) $$

Los distintos métodos difieren principalmente en su forma de modelar el kernel K. Por ejempo:

\begin{itemize}
\item En ISIS \citep{Alard_1998} el kernel $K$ es descompuesto como la suma de funciones analiticas lineales.
        $$K(u,v) = \sum_{n}a_nK_n(u,v)$$ donde $$K_n(u,v)=e^{\frac{-(u^2+v^2)}{2\sigma_k^2}}u_iv_i$$
\item En DANDIA \citep{Bramich_2008} el kernel $K$ es descompuesto como una malla de píxeles discretos.
\end{itemize}


ISIS es un paquete de fotometría especializado en la detección de estrellas 
variables en campos moderadamente densos, como se indica y es puesto en 
práctica en su manual.

La serie de pasos realizados por ISIS para la detección de estrellas 
variables corresponden primero a la alineación del conjunto de observaciones 
del campo deseado, para después generar una imagen de referencia con un 
buen \textit{signal-to-noise}, tomando un pequeño conjunto de las imágenes con 
mejor seeing de nuestras observaciones. Posteriormente se aplica una 
convolución entre la referencia y cada una de las imágenes de ciencia, 
obteniendo el kernel que caracteriza las condiciones de seeing. 
La imagen de referencia convolucionada para igualar el seeing se 
sustrae a la de ciencia, dando como resultado una serie de imágenes 
sustraídas, donde se pueden observar residuos correspondientes a variaciones 
de flujo entre las dos imágenes. 

%-------------------------------------------------------------------
\section{Registro e Interpolación Astrométrica}
%-------------------------------------------------------------------

Un paso fundamental previo a la sustracción de imágenes es el registro e interpolación astrométrica 
de cada una de las imágenes. Este proceso consiste en ajustar las imágenes 
para que estén alineadas espacialmente y se adapten al mismo sistema de 
coordenadas, lo que facilita su comparación.
El registro astrométrico se encarga de alinear las imágenes, asegurando que 
todas compartan un sistema de coordenadas común. Posteriormente, la interpolación 
astrométrica adapta las imágenes registradas a este sistema, garantizando 
que los píxeles de cada imagen correspondan a las mismas posiciones en el cielo.

Es común que el conjunto de imágenes de observación de un campo pueda presentar 
variaciones espaciales correspondientes al centrado, orientación y escala de las imágenes. \citep{Alard_1998}.  
Entre las distintas fuentes de inconsistencia de las imágenes tomadas en 
un observatorio, podemos mencionar fallos del guiador, condiciones 
ambientales y condiciones mecánicas que ocasionan movimientos en el 
telescopio, observaciones realizadas a lo largo de más de una noche, entre otras.

Al procedimiento de mapear puntos de una imagen a sus correspondientes 
puntos en otra imagen se le llama Registro de imágenes. Esta es una 
transformación espacial que tiene como propósito 
hacer que el conjunto de observaciones coincidan en sus características 
más generales, esto es, alinearlas al mismo sistema de referencia de 
forma que las posiciones de cada estrella coincidan entre cada imagen. 
De no hacer dicho ajuste, la ausencia y presencia de una determinada 
estrella en una posición específica entre distintas imágenes puede ser 
interpretada como variaciones astronómicas. 

Para ejecutar el procedimiento de registro e interpolación, se elige 
una imagen de referencia, la cual debe contener todos nuestros 
objetos de interés en las posiciones que consideremos favorables 
para nuestro propósito. Una observación a tomar en cuenta para beneficio 
de los pasos subsecuentes es procurar que nuestros objetos de especial 
interés no se encuentren muy próximos a los bordes de la imagen. 

Una vez elegida la imagen de referencia, se debe especificar el 
grado del polinomio bidimensional \texttt{process\_config/DEGREE} correspondiente 
al proceso astrométrico de remapeo. Esto implica el mapeo de cada 
píxel de la imagen al sistema de referencia, corrigiendo desplazamientos, 
rotaciones y otras posibles distorsiones ópticas. El polinomio se calcula 
mediante el ajuste de un modelo a las diferencias entre coordenadas 
de estrellas o puntos de referencia comunes en ambas imágenes. Un catálogo 
de dichos objetos es extraído por el programa usando un algoritmo muy 
rápido (alard-old-registration). 
Para registrar todas las imágenes a un marco de referencia, se usa un 
ajuste polinómico 2D. Las coordenadas de los puntos de referencia en la 
imagen fuente $(x, y)$ y en la referencia $(x', y')$ se registran mediante 
una transformación $(x', y') = T(x,y)$
donde $T(x, y)$: 

$$x' = a_0 + a_1x + a_2y + a_3x^2 + a_4xy + a_5y^2 + ...$$
$$y' = b_0 + b_1x + b_2y + b_3x^2 + b_4xy + b_5y^2 + ...$$

Esta transformación define puntos en la malla entre los puntos de la 
malla original. 

Las imágenes digitales están compuestas por valores discretos, correspondientes 
a píxeles. Sin embargo las transformaciones geométricas pueden generar 
coordenadas no enteras. Es necesaria entonces una interpolación de los 
valores en la malla original para estimar los valores de la imagen en 
la nueva malla de referencia. Esto se logra mediante \textit{Bicubic Splines Interpolation}, 
un método que utiliza un total de 16 ($4x4=$) píxeles adyacentes para lograr una 
interpolación con un resultado mas suavizado que con una implementación lineal \citep{Xia_2013}. 

% DIAGRAMA BICUBIC INTERPOLATIONS
%\figura{Subtraction/bicubic_interp}{width=.5\textwidth}{fig:bicubic-interp;}%
%{Diagrama del algoritmo Bicubic Interpolation}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.5\textwidth]{Subtraction/bicubic_interp}
  \caption{Diagrama del algoritmo \textit{Bicubic Interpolation}}
  \label{fig:bicubic_interp}
\end{figure}

El proceso de registro e interpolación astrométrica es ejecutado por
ISIS mediante \texttt{./interp.csh}
dando como resultado una serie de imágenes \texttt{interp\_*.fits} necesarias 
para los pasos posteriores. 

%-------------------------------------------------------------------
\section{Construcción de la imagen de referencia}
%-------------------------------------------------------------------
\label{cap3:sec:reference}


La imagen de referencia es aquella que se sustraerá o se verá sustraída 
con cada una de las imágenes de ciencia, siendo los residuos de cada una de estas restas 
representativos de la variación de los objetos en la imagen respecto al momento fijo de la imagen 
de referencia. 

Esta imagen debe tener la característica de ser la de mejor calidad entre todas. Para posteriormente 
ser degradada por medio de la convolución con el kernel y hacerla coincidir con las condiciones de la imagen de ciencia correspondiente. 
Se puede definir como una imagen específica de entre nuestro conjunto o bien se puede construir por medio de un conjunto de imágenes de la mejor calidad


En ISIS, para la construcción de la imagen de referencia se debe explorar el 
conjunto de imágenes y seleccionar aproximadamente las 10 de mejor calidad 
en cuanto a seeing y condiciones atmosféricas. Las imágenes seleccionadas 
se listan en el archivo \texttt{register<i>/ref\_list}. %Las imágenes tienen diferente 
%fondo y diferente seeing. 
%El propósito de la imagen de referencia es 
%asemejar las condiciones de cada una de las demás imágenes mediante una 
%convolución.

Si bien el paquete cuenta con la opción de construir la imagen de referencia 
mediante una simple adición, este método tiene la principal desventaja de 
que, de haber errores en las imágenes listadas, estos se acumularán 
haciéndose evidentes en la imagen de referencia. 

Es por eso que ISIS incluye con otro procedimiento más recomendado y 
que aprovecha los fundamentos de su implementación de la sustracción 
de imágenes, capaz de lidiar con defectos puntuales en nuestra lista de 
mejores imágenes, lo cual representa la principal ventaja de elegir un 
conjunto de mejores imágenes en lugar de una puntual. 
Con la intención de construir la imagen de referencia 
como una mediana de cada pixel en la lista de imágenes, primero se 
implementa el mismo procedimiento que se desarrolló para la sustracción 
que se describe más adelante: igualar las condiciones de cada una de las 
imágenes en la lista mediante un kernel de convolución. Respetando así 
los valores de cada imagen independiente y su aporte a la mediana. 
En este caso se elige $R$ (imagen de referencia para la convolución) 
indicando el nombre de la imagen en el parámetro \texttt{REF\_STACK} del archivo \texttt{process\_config}.

Una vez que las imágenes hayan sido transformadas para coincidir con 
la mejor de ellas (la indicada en el \texttt{REF\_STACK}), cada píxel 
a lo largo de todas las imágenes será filtrado mediante 3 sigma 
rejection alrededor de la mediana. Se utiliza la mediana en lugar de 
la media ya que funciona mejor para filtrar el tipo de ruido común 
en imágenes astronómicas.

Todo este proceso se realiza ejecutando \texttt{./ref.csh}

%-------------------------------------------------------------------
\section{Sustracción de imágenes}
%-------------------------------------------------------------------
\label{cap3:sec:sustraction}

La sustracción de imágenes es un método que permite emparejar los rasgos más generales 
de una imagen frente a otra mediante distintas técnicas. De forma que puedan ser 
diferenciadas para detectar y medir objetos variables. 

ISIS generaliza para el caso de kernels espacialmente variables sin aumentar el 
costo computacional. Además, impone un escalado constante del flujo entre las 
imágenes (integral del kernel constante), manteniendo una relación fija en el 
brillo de los objetos entre las imágenes. Esto nos asegura que el brillo de los 
objetos se mantenga proporcional en todas las imágenes y garantiza que el ajuste 
del kernel no modifique artificialmente el flujo total.

La esencia del método es encontrar un kernel de convolución $K$, que transforme 
una imagen de referencia $R$ para ajustarse a una imagen dada $I$.

Esto se logra mediante el método de mínimos cuadrados:
$$ \sum_{i}([R \ast K](x_i, y_i) - I(x_i, y_i))^2 $$

Donde el kernel es expresado en sus funciones base (gaussianas para ISIS)
$$ K(u,v) = \sum_{n}a_nK_n(u,v) $$
con 
$$ K_n(u,v)=e^{\frac{-(u^2+v^2)}{2\sigma_k^2}}u_iv_i $$

resolviendo para kernel espacialmente variable:
$$ K(u,v) = \sum_{n}a_n(x,y)K_n(u,v) $$

con los coeficientes $a_n$ siendo funciones polinomiales de $(x, y)$
$$ a_n(x,y) = \sum_{i,j} b_{i,j} x^i y^j$$


En el proceso de emparejar el seeing entre las imágenes mediante el kernel de 
convolución, se debe tener especial cuidado en 
que la suma del kernel sea constante. De lo contrario, podría causar que el flujo 
de los objetos en la imagen cambie inesperadamente. 

Un escalado de flujo constante implica que, aunque las imágenes puedan tener 
diferencias en resolución, enfoque, o ruido, se asegura que el flujo total entre 
las imágenes sea proporcional. Esto permite una comparación más directa.

Se impone entonces la restricción de que el flujo total de la imagen no cambie después 
de la transformación. Esto se puede hacer mediante multiplicadores de Lagrange, 
sin embargo resultaría computacionalmente costoso. Es por eso que se opta por  
rediseñar la base de los vectores que forman el kernel. 

nueva base de los vectores del kernel que son combinaciones lineales de los vectores de los 
vectores anteriores. Este nuevo conjunto de vectores se construye de forma que cada vector base, a excepción 
de uno, sumen cero. Se hace entonces la combinación: 

$$ K'_n = K_n - K_0 $$ 

donde el vector $K_n$ está normalizado y los vectores $K'_n$ suman cero a excepcion de $K'_0$ 
que será igual a $K_0$. Así, la expresión del kernel queda como: 

$$ K(u,v) = a_0 K_0(u,v) + \sum_{1,N}a_n(x,y)K'_n(u,v) $$


Separamos un vector base especial $K_0$ que controla el flujo total, de otros 
vectores $K_n'$ encargados de afectar la forma de la transformación, más que 
actuar sobre el brillo y flujo.

Una vez encontrado el kernel, este se convoluciona con la imagen de referencia 
y el resultado se sustrae a su correspondiente imagen de ciencia. Esto se aplica 
sobre todo nuestro conjunto de imágenes,
produciendo una serie de imágenes de diferencia. 

Les llamamos imágenes de diferencia a las que se obtienen como resultado de la resta entre la 
imagen de referencia convolucionada y la de ciencia. Donde los residuos corresponden a posible 
variabilidad.

Sin embargo, estos residuos pueden tener su origen debido a una variedad de factores 
no necesariamente astronómicos debidos a pequeños fallos de alineamiento, estrellas saturadas 
o un ajuste deficiente de la PSF.

Este proceso es realizado por ISIS mediante el comando \texttt{./subtract.csh}, posterior al ajuste de 
parámetros como el tamaño del kernel (\texttt{half\_mesh\_size}) y del área considerada alrededor de cada objeto (\texttt{half\_stamp\_size}) en el archivo
\texttt{default\_config}


%-------------------------------------------------------------------
\section{Detección de variables}

Para mejorar las probabilidades de encontrar estrellas variables y objetos transitorios, una imagen de mediana de 
diferencias es construida, donde cada pixel es la mediana del set de pixeles correspondientes 
al conjunto de imágenes de diferencia. 

Cualquier residuo visible en la imagen de mediana de diferencias es un indicativo de cambio 
de flujo entre las dos imágenes. Este cambio visible puede deberse tanto a un auténtico 
cambio de flujo debido a una estrella variable, como a ruido sistemático 
(\textit{flat-field} o fallos en la PSF modelada).

Para tener mejor oportunidad de identificar las 
variaciones de nuestro interés, generamos una imagen de medias de diferencias 
(\texttt{var.fits}) donde cada pixel es la mediana del conjunto correspondiente 
de píxeles en cada una de las imágenes de diferencia. De esta forma se reduce 
la influencia de errores sistemáticos, minimizando falsos positivos causados 
por fluctuaciones no astronómicas.

%\texttt{var.fits} es la media de las desviaciones absolutas normalizadas, 
%y \texttt{abs.fits} es la media de las desviaciones absolutas de los valores de los píxeles.

%for pixel in fits: mediana(dif1.fits, dif2.fits, ?, dif_n.fits)

ISIS construye esta imagen de mediana de diferencias y el archivo 
\texttt{phot.data} mediante el comando \texttt{./detect.csh}

Los objetos destacados en \texttt{var.fits} son listados 
en el archivo \texttt{phot.data} al ejecutar el comando \texttt{./find.csh} 
de acuerdo a un \textit{threshold} (\texttt{SIG\_THRESH}) 
establecido en el archivo \texttt{process\_config}


%-------------------------------------------------------------------
\section{Fotometría y curvas de luz}
%-------------------------------------------------------------------
\label{cap3:sec:fotometria}

El proceso de construcción de las curvas de luz se reduce a la estimación del flujo relativo 
a lo largo de cada una de las imágenes de diferencia en un punto especifico. Dando como resultado 
un archivo que incluye dicho flujo acompañado de la fecha indicada en \texttt{dates} correspondiente 
a la imagen. Los puntos sobre los cuales se construyen las curvas de luz son los indicados en el archivo \texttt{phot.data}: 

\begin{verbatim}
47.818095 53.288971 48 53 lc0.data 1.108024 18.838448
98.324050 53.530079 99 53 lc1.data 0.530456 6.804914
149.000000 105.000000 149 105 lc2.data 1.504538 20.553673
177.773145 153.121297 177 153 lc3.data 0.579896 13.999767
197.284906 203.871915 197 204 lc4.data 0.291704 9.640295
...
\end{verbatim}

generado en el paso anterior, en el cual se incluyen los nombres de las curvas de luz 
a generar y las coordenadas \textit{physical} del objeto en el 
siguiente orden de columnas: 
\texttt{x}, \texttt{y}, \texttt{int(x)}, \texttt{int(y)}, \texttt{name.data}, \texttt{var.fits}, \texttt{abs.fits}.

Las curvas se generan mediante el comando \texttt{./phot.data} con el nombre 
indicado en \texttt{phot.data}, que por defecto van como 
\texttt{lc<i>.data} y se almacenan en el directorio de imagenes.  

Los parámetros fotométricos del proceso como el radio de apertura (\texttt{rad\_aper}) 
y de \textit{background} (\texttt{rad1\_bg}, \texttt{rad2\_bg}) se indican 
en el archivo \texttt{phot\_config}

Una observación importante a señalar es que para este trabajo descubrimos la posibilidad de interrumpir el 
flujo del programa y modificar manualmente el archivo \texttt{phot.data} para realizar 
fotometría y curvas de luz en coordenadas de nuestro interés específico.





%-------------------------------------------------------------------
%\section*{\NotasBibliograficas}
%-------------------------------------------------------------------
%\TocNotasBibliograficas

%Citamos algo para que aparezca en la bibliografía\ldots
%\citep{ldesc2e}

%\medskip

%Y también ponemos el acrónimo \ac{CVS} para que no cruja.

%Ten en cuenta que si no quieres acrónimos (o no quieres que te falle la compilación en ``release'' mientras no tengas ninguno) basta con que no definas la constante \verb+\acronimosEnRelease+ (en \texttt{config.tex}).


%-------------------------------------------------------------------
%\section*{\ProximoCapitulo}
%-------------------------------------------------------------------
%\TocProximoCapitulo

% Variable local para emacs, para  que encuentre el fichero maestro de
% compilación y funcionen mejor algunas teclas rápidas de AucTeX
%%%
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../Tesis.tex"
%%% End:
